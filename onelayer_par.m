function [density,curve,time_simulation_end_early,centerdensincrease,g] ...    = onelayer_par(paramval,filestring,growthfunction,time,number_nodes,...    exp_px,exp_scale)% [density,curve,time_simulation_end_early,centerdensincrease] ...%     = onelayer_par(paramval,filestring,growthfunction,time,number_nodes,...%     exp_px,exp_scale)%% This function is the main file that solves the spatial formulation of the% 2-D 1-layer cell migration Stefan problem%% ************************** TO RUN IN PARALLEL **************************%% input:%   param = parameters (vector with Fk,kb,rho0) - note that Fk = F/k and%           kb = k/b due to parameter identifiability%% outputs:%   density    = density%   curve      = boundary location coordinates%   Phi        = level set%   plot_times = times at which the contours are drawnparam.Fk = paramval(1);param.kb = paramval(2);param.alpha = paramval(3);param.rho0 = paramval(4);%%%------------------------- initial densites --------------------------%%%% param.rho0*exp(param.Fk) is a layer NOT at equilibrium% param.rho0*exp(-param.Fk) is a layer at equilibriuminit_cond.in = 4700; %cells/mm^2      %param.rho0*exp(param.Fk);init_cond.out = 0; %%% outside the colonyinit_cond.bdy = param.rho0*exp(-param.Fk); %%% on the boundary%%%--------------------------- generate mesh ---------------------------%%%g = mesh_generation(number_nodes,exp_px,exp_scale);%%%------------------- initial cell boundary shapes --------------------%%%%%%---------------------- (initialize level sets) ----------------------%%%Phi_init = experimentalshape(strcat(filestring,'1.txt'),...    strcat(filestring,'initial_mask.tif'),exp_scale,g);%%%--------------------- build diffusion matrices ----------------------%%%[lapl.Lxx,lapl.Lyy] = laplacian_discretize(param,g);%%%-------------------------- time parameters --------------------------%%%time.ini = 0;              %%% initial time is 0time.CFL = 0.25;           %%% constant for the CFL condition %0.25time.dt_too_small = 1e-10; %%% minimum time step that can be takentime_simulation_end_early = 0; %%% cell boundary stays within computational                               %%% domain and simulation does not end early                               %%% (set =1 later in code if this changes)%%%------------------------- re-initialization -------------------------%%%reinit.band = 5;reinit.ITERMAX = 10;reinit.TOL = 0.05;%%%---------------------- level sets and density -----------------------%%%Phi0 = Phi_init;C0 = init_cond.bdy + (init_cond.in - init_cond.bdy).*max(sign(Phi0),0) ...    - (init_cond.out - init_cond.bdy).*min(sign(Phi0),0);init_mass = sum(sum(C0))*g.dx*g.dy;Phi_old = Phi0;C_old = C0;Phi_new = Phi0;t = time.ini;plot_times = time.ini;%%% for post-processingframecount = 1;density{1} = C0;curve{1} = contourc(g.x,g.y,Phi_new,[0 0])';curve{1} = curve{1}(2:end,:); %remove extraneous coordinatePhi{1} = Phi0;newmassadded(1) = 0;massadded = 0;mmm = 1;time.timewholesim(1) = time.ini;%%%---------------------------------------------------------------------%%%%%%---------------------------------------------------------------------%%%%%%---------------------------- WHILE LOOP -----------------------------%%%tic;while t < time.end    %%%--------------------- 1. calculate the velocity ---------------------%%%    [Vx,Vy,Veta,Vzeta,Gs] = cartesian_velocity(param,Phi_old,C_old,g,init_cond);        if isnan(Vx(1,1))==1 || isnan(Vy(1,1))==1 || isnan(Veta(1,1))==1 ...            || isnan(Vzeta(1,1))==1 || isstruct(Gs)==0        time_simulation_end_early = 1;        centerdensincrease = 0.5;        disp('cell boundary outside of computational domain')        return    end%%%--------------- 1.2 calculate the time step according ---------------%%%%%%---------------------- to stability conditions ----------------------%%%    maxVel = max(abs(Vx(:)))/g.dx + max(abs(Vy(:)))/g.dy ...                + max(abs(Veta(:)))/sqrt(g.dx^2 + g.dy^2) ...                + max(abs(Vzeta(:)))/sqrt(g.dx^2+g.dy^2);    dt_CFL = time.CFL/max(maxVel);               if dt_CFL < time.dt_too_small        disp('Time step too small!')        dt_CFL = time.dt_too_small;    end    dt = .5*dt_CFL;        if t+dt > framecount*time.exp_step        dt = framecount*time.exp_step-t;        t = framecount*time.exp_step; %%% avoids round-off error    else        t = t + dt;    end%%%---------------------- 2. update the level set ----------------------%%%    Phi_new = levelset_update(Phi_old,dt,Vx,Vy,Veta,Vzeta,Gs,g);    %%%------------------ 2.1 reinitialize the level set -------------------%%%    Phi_new = levelset_reinitialize(Phi_new,0.2*g.dx,3,g,reinit);%%%------------------ 3. solve the diffusion equation ------------------%%%    % add in growth    [C_old,ma] = feval(str2func(growthfunction),param,C_old,dt,t,...        massadded,g,init_mass);        newmassadded(mmm) = ma;    massadded = massadded + newmassadded(mmm);    time.timewholesim(mmm+1) = t;    mmm = mmm+1;    C_new = solve_diff(param,lapl,C_old,Phi_old,Phi_new,dt,g,init_cond);%%%------------ 4. prepare variable for the next time step -------------%%%    C_old = C_new;    Phi_old = Phi_new;%%%------- 5. post-processing: graphical output, find interface --------%%%    if  t == framecount*time.exp_step %%% only plots timesteps that                                      %%% align w/ experimental time points    %         fprintf('t = %g\n',t);                framecount = framecount + 1;                %%% plotting and saving contours        curve{framecount} = contourc(g.x,g.y,Phi_new,[0 0])';        curve{framecount} = curve{framecount}(2:end,:); %remove extraneous coordinate                density{framecount} = C_new;        Phi{framecount} = Phi_new;                plot_times = [plot_times t];    endend%%% if the density (in the center) increases over time, set%%% centerdensincrease=1centerdensincrease = 0;xmid = ceil((g.Nx+1)/2);ymid = ceil((g.Ny+1)/2);centerdensity = zeros(length(density),1);for i = 1:length(density)    centerdensity(i) = density{i}(ymid,xmid);endif max(diff(centerdensity))>0.5    centerdensincrease = 1;    disp('density increased in the center')endtoc;
function [density,curve,area,velocity,Phi,curvature,plot_times,...    newmassadded] = onelayer_varyingkb(param)% [density,curve,velocity,Phi,curvature,plot_times,...%    newmassadded] = onelayer_varyingkb(param)%% This function is the main file that solves the spatial formulation of the% 2-D 1-layer cell migration Stefan problem%% input:%   param = parameters (structure with Fk,kb,rho0) - note that Fk = F/k and%           kb = k/b due to parameter identifiability%% outputs:%   density    = density%   curve      = boundary location coordinates%   velocity   = average instantaneous normal velocity at the cell layer%                edge%   Phi        = level set%   plot_times = times at which the contours are drawn%% note:%   figureson: figures on? 1=yes, 0=noglobal g time init_cond reinit figureson init_mass;global number_nodes exp_px exp_scale filestring growthfunction;%%%------------------------- initial densites --------------------------%%%% param.rho0*exp(param.Fk) is a layer NOT at equilibrium% param.rho0*exp(-param.Fk) is a layer at equilibriuminit_cond.in = 4700; %cells/mm^2      %param.rho0*exp(param.Fk);init_cond.out = 0; %%% outside the colonyinit_cond.bdy = param.rho0*exp(-param.Fk); %%% on the boundary%%%--------------------------- generate mesh ---------------------------%%%g = mesh_generation(number_nodes,exp_px,exp_scale);%%%------------------- initial cell boundary shapes --------------------%%%%%%---------------------- (initialize level sets) ----------------------%%%Phi_init = experimentalshape(strcat(filestring,'1.txt'),...    strcat(filestring,'initial_mask.tif'),exp_scale);%%%--------------------- build diffusion matrices ----------------------%%%%%% set up for Pos14exp8!mask = double(imread(strcat(filestring,'last_mask.tif'),'tif'));xmask = linspace(g.xmin,g.xmax,size(mask,2));ymask = linspace(g.ymin,g.ymax,size(mask,1));[xMask,yMask] = meshgrid(xmask,ymask);interpol = interp2(xMask,yMask,mask,g.Xnew,g.Ynew)>0;newMask = interpol + (interpol-1);KBxrange = [1,2.5].*param.kb;KByrange = [0.05,0.25].*param.kb;KBx1 = (KBxrange(2)-KBxrange(1)).*rand(g.Ny+1,g.Nx+1) + KBxrange(1);KBy1 = (KByrange(2)-KByrange(1)).*rand(g.Ny+1,g.Nx+1) + KByrange(1);KB.x = KBx1;KB.y = KBy1;% KBx1 = param.kb.*ones(g.Ny+1,g.Nx+1);% KBy1 = param.kb.*ones(g.Ny+1,g.Nx+1);KB.x = KBx1.*(newMask>0) + 0.1*param.kb.*(newMask<0);KB.y = KBy1.*(newMask>0) + 0.1*param.kb.*(newMask<0);[lapl.Lxx,lapl.Lyy] = laplacian_discretize_anisotropic(KB);%%%-------------------------- time parameters --------------------------%%%time.ini = 0;              %%% initial time is 0time.CFL = 0.25;           %%% constant for the CFL condition %0.25time.dt_too_small = 1e-10; %%% minimum time step that can be takentime.simulation_end_early = 0; %%% cell boundary stays within computational                               %%% domain and simulation does not end early                               %%% (set =1 later in code if this changes)%%%------------------------- re-initialization -------------------------%%%reinit.band = 5;reinit.ITERMAX = 10;reinit.TOL = 0.05;%%%---------------------- level sets and density -----------------------%%%Phi0 = Phi_init;C0 = init_cond.bdy + (init_cond.in - init_cond.bdy).*max(sign(Phi0),0) ...     - (init_cond.out - init_cond.bdy).*min(sign(Phi0),0);init_mass = sum(sum(C0))*g.dx*g.dy;Phi_old = Phi0;C_old = C0;Phi_new = Phi0;t = time.ini;plot_times = time.ini;%%% plotting and saving contoursif figureson==1    plots_contourdensity(Phi_new,C_old,'first');end%%% for post-processingframecount = 1;density{1} = C0;curve{1} = contourc(g.x,g.y,Phi_new,[0 0])';curve{1} = curve{1}(2:end,:); %remove extraneous coordinatearea(1) = polyarea(curve{1}(:,1),curve{1}(:,2));Phi{1} = Phi0;curvature{1} = curvature2D(Phi0);newmassadded(1) = 0;massadded = 0;mmm = 1;time.timewholesim(1) = time.ini;%%%---------------------------------------------------------------------%%%%%%---------------------------------------------------------------------%%%%%%---------------------------- WHILE LOOP -----------------------------%%%tic;while t < time.end%     fprintf('t = %g\n',t);    %%%--------------------- 1. calculate the velocity ---------------------%%%    [Vx,Vy,Veta,Vzeta,Gs] = cartesian_velocity_anisotropic(KB,Phi_old,C_old);        if isnan(Vx(1,1))==1 || isnan(Vy(1,1))==1 || isnan(Veta(1,1))==1 ...            || isnan(Vzeta(1,1))==1 || isstruct(Gs)==0        time.simulation_end_early = 1;        disp('cell boundary outside of computational domain')        return    end        if t==0        [vnormal,arclengths] = velocityarclength(Phi_new,curve{1},Vx,Vy);        %%% estimate velocity along entire line segment; segments have        %%% different lengths (longer it is, the more it will contribute to        %%% the velocity) (discretizing integral)        velocity(1) = sum((vnormal(1:end-1) + vnormal(2:end))./2 ...                                            .*arclengths)./sum(arclengths);    end%%%--------------- 1.2 calculate the time step according ---------------%%%%%%---------------------- to stability conditions ----------------------%%%    maxVel = max(abs(Vx(:)))/g.dx + max(abs(Vy(:)))/g.dy ...                + max(abs(Veta(:)))/sqrt(g.dx^2 + g.dy^2) ...                + max(abs(Vzeta(:)))/sqrt(g.dx^2+g.dy^2);    dt_CFL = time.CFL/max(maxVel);               if dt_CFL < time.dt_too_small        disp('Time step too small!')        dt_CFL = time.dt_too_small;    end    dt = .5*dt_CFL;        if t+dt > framecount*time.exp_step        dt = framecount*time.exp_step-t;        t = framecount*time.exp_step; %%% avoids round-off error    else        t = t + dt;    end%%%---------------------- 2. update the level set ----------------------%%%    Phi_new = levelset_update(Phi_old,dt,Vx,Vy,Veta,Vzeta,Gs);    %%%------------------ 2.1 reinitialize the level set -------------------%%%    Phi_new = levelset_reinitialize(Phi_new,0.2*g.dx,3);%%%------------------ 3. solve the diffusion equation ------------------%%%    % add in growth    [C_old,ma] = feval(str2func(growthfunction),param,C_old,dt,t,massadded);        newmassadded(mmm) = ma;    massadded = massadded + newmassadded(mmm);    time.timewholesim(mmm+1) = t;    mmm = mmm+1;    C_new = solve_diff_anisotropic(KB,lapl,C_old,Phi_old,Phi_new,dt);%%%------------ 4. prepare variable for the next time step -------------%%%    C_old = C_new;    Phi_old = Phi_new;%%%------- 5. post-processing: graphical output, find interface --------%%%    if  t == framecount*time.exp_step %%% only plots timesteps that                                      %%% align w/ experimental time points    %         fprintf('t = %g\n',t);                framecount = framecount + 1;                %%% plotting and saving contours        curve{framecount} = contourc(g.x,g.y,Phi_new,[0 0])';        curve{framecount} = curve{framecount}(2:end,:); %remove extraneous coordinate        if figureson==1            plots_contourdensity(Phi_new,C_new);        end                density{framecount} = C_new;        area(framecount) = polyarea(curve{framecount}(:,1),...                                                   curve{framecount}(:,2));                [vnormal,arclengths] = velocityarclength(Phi_new,...                                                  curve{framecount},Vx,Vy);                velocity(framecount) = sum((vnormal(1:end-1) ...            + vnormal(2:end))./2.*arclengths)./sum(arclengths);                curvature{framecount} = curvature2D(Phi_new);        Phi{framecount} = Phi_new;                plot_times = [plot_times t];    endend% if figureson==1%     plots_edgevelocity(plot_times,velocity)% endtoc;